{"version":3,"sources":["../../webpack/bootstrap","../../external \"~config\"","../../external \"node-persist\"","../../external \"express\"","../../external \"~express/middleware/auth/passport.js\"","../../external \"~marko\"","../../src/express/index.js","../../src/poly.js","../../src/express/server-actions.js","../../src/express/middleware/index.js","../../src/express/middleware/cache/index.js","../../src/express/middleware/cache/add-storage.js","../../src/express/middleware/cache/cache-type/index.js","../../src/express/middleware/cache/cache-type/album.js","../../src/express/middleware/cache/cache-type/lastSeen.js","../../src/express/middleware/cache/cache-type/mediaItem.js","../../src/express/middleware/auth/index.js","../../src/express/middleware/auth/passport.js","../../external \"passport\"","../../external \"passport-google-oauth20\"","../../src/config.js","../../src/express/middleware/session/index.js","../../src/express/middleware/session/create-session-middleware.js","../../external \"express-session\"","../../external \"session-file-store\"","../../src/express/middleware/session/store-session-data.js","../../src/express/middleware/logging/index.js","../../src/express/middleware/logging/logger.js","../../external \"winston\"","../../external \"express-winston\"","../../external \"request-promise\"","../../src/express/route/index.js","../../external \"request\"","../../external \"serve-static\"","../../src/express/route/auth/index.js","../../src/express/route/auth/methods/index.js","../../src/express/route/auth/methods/logout.js","../../src/express/route/auth/methods/login.js","../../src/express/route/auth/methods/redirect.js","../../external \"~express/middleware/logging\"","../../src/express/route/marko/index.js"],"names":[],"mappings":"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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;;AAE5C;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,sDAAsD;AACrE,KAAK;AACL;AACA;AACA;AACA,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;;AAE3E;AACA;AACA;AACA,eAAe,mDAAmD;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2BAA2B;AAC3E;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA,mBAAmB;AACnB;AACA;;AAEA,kCAAkC,OAAO;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA,WAAW;AACX;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,2DAA2D,cAAc;AACzE;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA,iBAAiB;AACjB,SAAS;;AAET,kCAAkC,OAAO;;AAEzC;AACA,uDAAuD,qBAAqB;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;;;;;;;ACjXA,oC;;;;;;ACAA,yC;;;;;;ACAA,OAAO,SAAS,GAAG,mBAAO,CAAC,CAAS;AACpC,OAAO,QAAQ,GAAG,mBAAO,CAAC,EAAW;;AAErC;AACA;AACA,gBAAgB,yBAAyB;;AAEzC;;;;;;;ACPA,OAAO,SAAS,GAAG,mBAAO,CAAC,EAAa;AACxC,OAAO,cAAc,GAAG,mBAAO,CAAC,EAAY;AAC5C,OAAO,sBAAsB,GAAG,mBAAO,CAAC,EAAe;;AAEvD;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA,OAAO,SAAS,GAAG,mBAAO,CAAC,CAAS;AACpC,OAAO,WAAW,GAAG,mBAAO,CAAC,CAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACXA,OAAO,WAAW,GAAG,mBAAO,CAAC,CAAsC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;;;;;ACfA,wD;;;;;;;ACAA;AAAA;AAAA;AAAA;AAA8B;;AAE9B;AACA;AACA,6CAA6C;AAC7C,IAAI,2CAAI,UAAU;AAClB,GAAG;AACH;AACA;;AAE2B","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/static/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = require(\"~config\");","module.exports = require(\"node-persist\");","module.exports = require(\"express\");","module.exports = require(\"~express/middleware/auth/passport.js\");","module.exports = require(\"~marko\");","require(\"../poly.js\");\r\n\r\n// import { createServer, runServer } from \"./server-actions.js\";\r\n// import { addMiddleware } from \"./middleware\";\r\n// import { addRoutes } from \"./route\";\r\nconst { createServer, runServer } = require(\"./server-actions.js\");\r\nconst addMiddleware = require(\"./middleware\");\r\nconst addRoutes = require(\"./route\");\r\n\r\nconst init = async () => {\r\n  let app = await createServer();\r\n  await addMiddleware(app);\r\n  await addRoutes(app);\r\n  await runServer(app);\r\n};\r\n\r\ninit().catch(console.error);\r\n","const fER = (a, [k, v]) => {\r\n  a[k] = v;\r\n  return a;\r\n};\r\nObject.fromEntries = Object.fromEntries || (entries => entries.reduce(fER, {}));\r\n","// import { config } from \"/sandbox/src/config.js\";\r\n// import express from \"express\";\r\nconst config = require(\"~config\");\r\nconst express = require(\"express\");\r\n\r\nconst createServer = async () => console.log(\"MAKING SERVER\") || new express();\r\nconst runServer = async app =>\r\n  console.log(\"MAKING SERVER LISTEN\") || app.listen(config.port);\r\n\r\nmodule.exports = { createServer, runServer };\r\n","// const cacheMiddleware = require(\"./cache\");\r\n// const authMiddleware = require(\"./auth\");\r\n// const sessionMiddleware = require(\"./session\");\r\nconst { cacheMiddleware } = require(\"./cache\");\r\nconst { authMiddleware } = require(\"./auth\");\r\nconst { sessionMiddleware } = require(\"./session\");\r\nconst { loggingMiddleware } = require(\"./logging\");\r\n\r\nconst middlewareList = [\r\n  {\r\n    order: 0,\r\n    name: \"logging\",\r\n    middleware: loggingMiddleware\r\n  },\r\n  {\r\n    order: 200,\r\n    name: \"cached\",\r\n    middleware: cacheMiddleware\r\n  },\r\n  {\r\n    order: 400,\r\n    name: \"session\",\r\n    middleware: sessionMiddleware\r\n  },\r\n  {\r\n    order: 600,\r\n    name: \"auth\",\r\n    middleware: authMiddleware\r\n  }\r\n];\r\n\r\nconst middlewareSort = (a, b) => a.order - b.order;\r\nmiddlewareList.sort(middlewareSort);\r\n\r\nconst addMiddleware = async app => {\r\n  console.log(\"ADDING MIDDLE\");\r\n  for (const { name, order, middleware } of middlewareList) {\r\n    console.log(`       NAME: ${name}\\n      ORDER: ${order}\\n`);\r\n    await middleware(app);\r\n  }\r\n  return app;\r\n};\r\n\r\nmodule.exports = addMiddleware;\r\n","const createStorage = require(\"./add-storage.js\");\r\nconst { album, storage, mediaItemCache } = require(\"./cache-type\");\r\n\r\nconst cacheMiddleware = async app =>\r\n  createStorage(app)\r\n    .add(album)\r\n    .add(storage)\r\n    .add(mediaItemCache)\r\n    .build();\r\n\r\nmodule.exports.cacheMiddleware = cacheMiddleware;\r\n","class makeAppStorage {\r\n  constructor(app) {\r\n    this.app = app;\r\n    this.storeEntries = [];\r\n  }\r\n\r\n  add(entry) {\r\n    this.storeEntries.push(entry);\r\n    return this;\r\n  }\r\n\r\n  createExpressFunction() {\r\n    const cache = Object.fromEntries(this.storeEntries);\r\n    return (req, res, next) => {\r\n      res.locals.cache = cache;\r\n      next();\r\n    };\r\n  }\r\n\r\n  build() {\r\n    this.app.use(this.createExpressFunction());\r\n    return this.app;\r\n  }\r\n}\r\n\r\nconst createStorage = app => new makeAppStorage(app);\r\n\r\nmodule.exports = createStorage;\r\n","const album = require(\"./album.js\");\r\nconst storage = require(\"./lastSeen.js\");\r\nconst mediaItemCache = require(\"./mediaItem.js\");\r\n\r\nmodule.exports = { album, storage, mediaItemCache };\r\n","const persist = require(\"node-persist\");\r\n\r\n// Temporarily cache a list of the albums owned by the user. This caches\r\n// the name and base Url of the cover image. This ensures that the app\r\n// is responsive when the user picks an album.\r\n// Loading a full list of the albums owned by the user may take multiple\r\n// requests. Caching this temporarily allows the user to go back to the\r\n// album selection screen without having to wait for the requests to\r\n// complete every time.\r\n// Note that this data is only cached temporarily as per the 'best practices' in\r\n// the developer documentation. Here it expires after 10 minutes.\r\nconst albumPersist = persist.create({\r\n  dir: \"persist-albumcache/\",\r\n  ttl: 600000 // 10 minutes\r\n});\r\nalbumPersist.init();\r\n\r\nconst albumCache = [\"albums\", albumPersist];\r\n\r\nmodule.exports = albumCache;\r\n","const persist = require(\"node-persist\");\r\n\r\n// For each user, the app stores the last search parameters or album\r\n// they loaded into the photo frame. The next time they log in\r\n// (or when the cached data expires), this search is resubmitted.\r\n// This keeps the data fresh. Instead of storing the search parameters,\r\n// we could also store a list of the media item ids and refresh them,\r\n// but resubmitting the search query ensures that the photo frame displays\r\n// any new images that match the search criteria (or that have been added\r\n// to an album).\r\nconst lastSeenPersist = persist.create({ dir: \"persist-storage/\" });\r\nlastSeenPersist.init();\r\n\r\nconst lastSeenCache = [\"lastSeen\", lastSeenPersist];\r\n\r\nmodule.exports = lastSeenCache;\r\n","const persist = require(\"node-persist\");\r\n\r\n// Set up a cache for media items that expires after 55 minutes.\r\n// This caches the baseUrls for media items that have been selected\r\n// by the user for the photo frame. They are used to display photos in\r\n// thumbnails and in the frame. The baseUrls are send to the frontend and\r\n// displayed from there. The baseUrls are cached temporarily to ensure that the\r\n// app is responsive and quick. Note that this data should only be stored for a\r\n// short amount of time and that access to the URLs expires after 60 minutes.\r\n// See the 'best practices' and 'acceptable use policy' in the developer\r\n// documentation.\r\nconst mediaItemsPersist = persist.create({\r\n  dir: \"persist-mediaitemcache/\",\r\n  ttl: 3300000 // 55 minutes\r\n});\r\nmediaItemsPersist.init();\r\n\r\nconst mediaItemCache = [\"mediaItems\", mediaItemsPersist];\r\n\r\nmodule.exports = mediaItemCache;\r\n","const passport = require(\"./passport.js\");\r\n\r\nconst authMiddleware = async app => {\r\n  app.use(passport.initialize());\r\n  app.use(passport.session());\r\n  return app;\r\n};\r\n\r\nmodule.exports.authMiddleware = authMiddleware;\r\n","const passport = require(\"passport\");\r\nconst Strategy = require(\"passport-google-oauth20\").Strategy;\r\nconst config = require(\"../../../config.js\");\r\n\r\nconst handleSerialize = (user, done) => done(null, user);\r\nconst handlePassportUse = (token, rt, profile, done) =>\r\n  done(null, { profile, token });\r\n\r\nconst strategyConfig = {\r\n  clientID: config.oAuthClientID,\r\n  clientSecret: config.oAuthClientSecret,\r\n  callbackURL: config.oAuthCallbackUrl,\r\n  userProfileURL: config.userProfileURL\r\n};\r\n\r\nconst effectiveStratagy = new Strategy(strategyConfig, handlePassportUse);\r\n\r\npassport.serializeUser(handleSerialize);\r\npassport.deserializeUser(handleSerialize);\r\npassport.use(effectiveStratagy);\r\n\r\nmodule.exports = passport;\r\n","module.exports = require(\"passport\");","module.exports = require(\"passport-google-oauth20\");","const googleSecretInfo = JSON.parse(process.env.GOOGLE_AUTH_JSON).web;\r\n\r\nconst config = {\r\n  userProfileURL: \"https://www.googleapis.com/oauth2/v3/userinfo\",\r\n  oAuthClientID: googleSecretInfo.client_id,\r\n  oAuthClientSecret: googleSecretInfo.client_secret,\r\n  oAuthCallbackUrl: googleSecretInfo.redirect_uris[0],\r\n  scopes: [\"profile\"],\r\n  port: 8080,\r\n  photosToLoad: 150,\r\n  searchPageSize: 100,\r\n  albumPageSize: 50\r\n};\r\n\r\nconst firebaseConfig = {\r\n  apiKey: \"AIzaSyDZkgQOsci95AU8ED555we6Jvmt97JuwSE\",\r\n  authDomain: \"file-preview-creator.firebaseapp.com\",\r\n  databaseURL: \"https://file-preview-creator.firebaseio.com\",\r\n  projectId: \"file-preview-creator\",\r\n  storageBucket: \"file-preview-creator.appspot.com\",\r\n  messagingSenderId: \"512751646365\",\r\n  appId: \"1:512751646365:web:ea38106612ceec93\"\r\n};\r\n\r\nmodule.exports = { config, firebaseConfig };\r\n","const initSessionMiddleware = require(\"./create-session-middleware.js\");\r\nconst addSessionDataToLocal = require(\"./store-session-data.js\");\r\n\r\nconst sessionMiddleware = async app => {\r\n  initSessionMiddleware(app);\r\n  addSessionDataToLocal(app);\r\n  return app;\r\n};\r\n\r\nmodule.exports.sessionMiddleware = sessionMiddleware;\r\n","const session = require(\"express-session\");\r\nconst sessionFileStore = require(\"session-file-store\");\r\n\r\nconst fileStore = sessionFileStore(session);\r\nconst sessionInstance = session({\r\n  resave: true,\r\n  saveUninitialized: true,\r\n  store: new fileStore({}),\r\n  secret: \"photo frame sample\"\r\n});\r\n\r\nconst initSessionMiddleware = app => app.use(sessionInstance);\r\n\r\nmodule.exports = initSessionMiddleware;\r\n","module.exports = require(\"express-session\");","module.exports = require(\"session-file-store\");","// Middleware that adds the user of this session as a local variable,\r\n// so it can be displayed on all pages when logged in.\r\nconst sessionDataAdder = (req, res, next) => {\r\n  res.locals.name = \"-\";\r\n  if (req.user && req.user.profile && req.user.profile.name) {\r\n    res.locals.name =\r\n      req.user.profile.name.givenName || req.user.profile.displayName;\r\n  }\r\n\r\n  res.locals.avatarUrl = \"\";\r\n  if (req.user && req.user.profile && req.user.profile.photos) {\r\n    res.locals.avatarUrl = req.user.profile.photos[0].value;\r\n  }\r\n  next();\r\n};\r\n\r\nconst addSessionDataToLocal = app => app.use(sessionDataAdder);\r\n\r\nmodule.exports = addSessionDataToLocal;\r\n","const { logger, transports } = require(\"./logger.js\");\r\nconst expressWinston = require(\"express-winston\");\r\n\r\nmodule.exports.loggingMiddleware = app => {\r\n  // Enable extensive logging if the DEBUG environment variable is set.\r\n  if (process.env.DEBUG) {\r\n    // Enable express.js debugging. This logs all received requests.\r\n    app.use(\r\n      expressWinston.logger({\r\n        transports: [transports],\r\n        winstonInstance: logger\r\n      })\r\n    );\r\n    // Enable request debugging.\r\n    require(\"request-promise\").debug = true;\r\n  }\r\n};\r\n","const winston = require(\"winston\");\r\n\r\n// Console transport for winton.\r\nconst consoleTransport = new winston.transports.Console();\r\n\r\nconst logger = winston.createLogger({\r\n  format: winston.format.combine(\r\n    winston.format.colorize(),\r\n    winston.format.simple()\r\n  ),\r\n  transports: [consoleTransport]\r\n});\r\n\r\n// Enable extensive logging if the DEBUG environment variable is set.\r\nif (process.env.DEBUG) {\r\n  // Print all winston log levels.\r\n  logger.level = \"silly\";\r\n} else {\r\n  // By default, only print all 'verbose' log level messages or below.\r\n  logger.level = \"verbose\";\r\n}\r\n\r\nmodule.exports.logger = logger;\r\nmodule.exports.transports = [consoleTransport];\r\n","module.exports = require(\"winston\");","module.exports = require(\"express-winston\");","module.exports = require(\"request-promise\");","// import baseRoute from \"./base\";\r\n// const baseRoute = require(\"./base\");\r\nconst request = require(\"request\");\r\nconst serveStatic = require(\"serve-static\");\r\nconst authRoute = require(\"./auth\");\r\nconst { logger } = require(\"~express/middleware/logging\");\r\nconst config = require(\"~config\");\r\nconst { routeMarkoPages } = require(\"./marko\");\r\n\r\nconst addRoutes = app => {\r\n  console.log(\"ADDING ROUTES\");\r\n  app.use(\"/static\", serveStatic(\"dist/client\"));\r\n  // app.use(\"/\", baseRoute);\r\n  app.use(\"/\", authRoute);\r\n  routeMarkoPages(app);\r\n\r\n  // Handles form submissions from the search page.\r\n  // The user has made a selection and wants to load photos into the photo frame\r\n  // from a search query.\r\n  // Construct a filter and submit it to the Library API in\r\n  // libraryApiSearch(authToken, parameters).\r\n  // Returns a list of media items if the search was successful, or an error\r\n  // otherwise.\r\n  app.post(\"/loadFromSearch\", async (req, res) => {\r\n    const authToken = req.user.token;\r\n\r\n    logger.info(\"Loading images from search.\");\r\n    logger.silly(\"Received form data: \", req.body);\r\n\r\n    // Construct a filter for photos.\r\n    // Other parameters are added below based on the form submission.\r\n    const filters = {\r\n      contentFilter: {},\r\n      mediaTypeFilter: { mediaTypes: [\"PHOTO\"] }\r\n    };\r\n\r\n    if (req.body.includedCategories) {\r\n      // Included categories are set in the form. Add them to the filter.\r\n      filters.contentFilter.includedContentCategories = [\r\n        req.body.includedCategories\r\n      ];\r\n    }\r\n\r\n    if (req.body.excludedCategories) {\r\n      // Excluded categories are set in the form. Add them to the filter.\r\n      filters.contentFilter.excludedContentCategories = [\r\n        req.body.excludedCategories\r\n      ];\r\n    }\r\n\r\n    // Add a date filter if set, either as exact or as range.\r\n    if (req.body.dateFilter == \"exact\") {\r\n      filters.dateFilter = {\r\n        dates: constructDate(\r\n          req.body.exactYear,\r\n          req.body.exactMonth,\r\n          req.body.exactDay\r\n        )\r\n      };\r\n    } else if (req.body.dateFilter == \"range\") {\r\n      filters.dateFilter = {\r\n        ranges: [\r\n          {\r\n            startDate: constructDate(\r\n              req.body.startYear,\r\n              req.body.startMonth,\r\n              req.body.startDay\r\n            ),\r\n            endDate: constructDate(\r\n              req.body.endYear,\r\n              req.body.endMonth,\r\n              req.body.endDay\r\n            )\r\n          }\r\n        ]\r\n      };\r\n    }\r\n\r\n    // Create the parameters that will be submitted to the Library API.\r\n    const parameters = { filters };\r\n\r\n    // Submit the search request to the API and wait for the result.\r\n    const data = await libraryApiSearch(authToken, parameters);\r\n\r\n    // Return and cache the result and parameters.\r\n    const userId = req.user.profile.id;\r\n    returnPhotos(res, userId, data, parameters);\r\n  });\r\n\r\n  // Handles selections from the album page where an album ID is submitted.\r\n  // The user has selected an album and wants to load photos from an album\r\n  // into the photo frame.\r\n  // Submits a search for all media items in an album to the Library API.\r\n  // Returns a list of photos if this was successful, or an error otherwise.\r\n  app.post(\"/loadFromAlbum\", async (req, res) => {\r\n    const albumId = req.body.albumId;\r\n    const userId = req.user.profile.id;\r\n    const authToken = req.user.token;\r\n\r\n    logger.info(`Importing album: ${albumId}`);\r\n\r\n    // To list all media in an album, construct a search request\r\n    // where the only parameter is the album ID.\r\n    // Note that no other filters can be set, so this search will\r\n    // also return videos that are otherwise filtered out in libraryApiSearch(..).\r\n    const parameters = { albumId };\r\n\r\n    // Submit the search request to the API and wait for the result.\r\n    const data = await libraryApiSearch(authToken, parameters);\r\n\r\n    returnPhotos(res, userId, data, parameters);\r\n  });\r\n\r\n  // Returns all albums owned by the user.\r\n  app.get(\"/getAlbums\", async (req, res) => {\r\n    logger.info(\"Loading albums\");\r\n    const userId = req.user.profile.id;\r\n\r\n    // Attempt to load the albums from cache if available.\r\n    // Temporarily caching the albums makes the app more responsive.\r\n    const cachedAlbums = await res.local.albumCache.getItem(userId);\r\n    if (cachedAlbums) {\r\n      logger.verbose(\"Loaded albums from cache.\");\r\n      res.status(200).send(cachedAlbums);\r\n    } else {\r\n      logger.verbose(\"Loading albums from API.\");\r\n      // Albums not in cache, retrieve the albums from the Library API\r\n      // and return them\r\n      const data = await libraryApiGetAlbums(req.user.token);\r\n      if (data.error) {\r\n        // Error occured during the request. Albums could not be loaded.\r\n        returnError(res, data);\r\n        // Clear the cached albums.\r\n        res.local.albumCache.removeItem(userId);\r\n      } else {\r\n        // Albums were successfully loaded from the API. Cache them\r\n        // temporarily to speed up the next request and return them.\r\n        // The cache implementation automatically clears the data when the TTL is\r\n        // reached.\r\n        res.status(200).send(data);\r\n        res.local.albumCache.setItemSync(userId, data);\r\n      }\r\n    }\r\n  });\r\n\r\n  // Returns a list of the media items that the user has selected to\r\n  // be shown on the photo frame.\r\n  // If the media items are still in the temporary cache, they are directly\r\n  // returned, otherwise the search parameters that were used to load the photos\r\n  // are resubmitted to the API and the result returned.\r\n  app.get(\"/getQueue\", async (req, res) => {\r\n    const userId = req.user.profile.id;\r\n    const authToken = req.user.token;\r\n\r\n    logger.info(\"Loading queue.\");\r\n\r\n    // Attempt to load the queue from cache first. This contains full mediaItems\r\n    // that include URLs. Note that these expire after 1 hour. The TTL on this\r\n    // cache has been set to this limit and it is cleared automatically when this\r\n    // time limit is reached. Caching this data makes the app more responsive,\r\n    // as it can be returned directly from memory whenever the user navigates\r\n    // back to the photo frame.\r\n    const cachedPhotos = await res.local.mediaItemCache.getItem(userId);\r\n    const stored = await res.local.storage.getItem(userId);\r\n\r\n    if (cachedPhotos) {\r\n      // Items are still cached. Return them.\r\n      logger.verbose(\"Returning cached photos.\");\r\n      res\r\n        .status(200)\r\n        .send({ photos: cachedPhotos, parameters: stored.parameters });\r\n    } else if (stored && stored.parameters) {\r\n      // Items are no longer cached. Resubmit the stored search query and return\r\n      // the result.\r\n      logger.verbose(\r\n        `Resubmitting filter search ${JSON.stringify(stored.parameters)}`\r\n      );\r\n      const data = await libraryApiSearch(authToken, stored.parameters);\r\n      returnPhotos(res, userId, data, stored.parameters);\r\n    } else {\r\n      // No data is stored yet for the user. Return an empty response.\r\n      // The user is likely new.\r\n      logger.verbose(\"No cached data.\");\r\n      res.status(200).send({});\r\n    }\r\n  });\r\n\r\n  // If the supplied result is succesful, the parameters and media items are\r\n  // cached.\r\n  // Helper method that returns and caches the result from a Library API search\r\n  // query returned by libraryApiSearch(...). If the data.error field is set,\r\n  // the data is handled as an error and not cached. See returnError instead.\r\n  // Otherwise, the media items are cached, the search parameters are stored\r\n  // and they are returned in the response.\r\n  function returnPhotos(res, userId, data, searchParameter) {\r\n    if (data.error) {\r\n      returnError(res, data);\r\n    } else {\r\n      // Remove the pageToken and pageSize from the search parameters.\r\n      // They will be set again when the request is submitted but don't need to be\r\n      // stored.\r\n      delete searchParameter.pageToken;\r\n      delete searchParameter.pageSize;\r\n\r\n      // Cache the media items that were loaded temporarily.\r\n      res.local.mediaItemCache.setItemSync(userId, data.photos);\r\n      // Store the parameters that were used to load these images. They are used\r\n      // to resubmit the query after the cache expires.\r\n      res.local.storage.setItemSync(userId, { parameters: searchParameter });\r\n\r\n      // Return the photos and parameters back int the response.\r\n      res\r\n        .status(200)\r\n        .send({ photos: data.photos, parameters: searchParameter });\r\n    }\r\n  }\r\n\r\n  // Responds with an error status code and the encapsulated data.error.\r\n  function returnError(res, data) {\r\n    // Return the same status code that was returned in the error or use 500\r\n    // otherwise.\r\n    const statusCode = data.error.code || 500;\r\n    // Return the error.\r\n    res.status(statusCode).send(data.error);\r\n  }\r\n\r\n  // Constructs a date object required for the Library API.\r\n  // Undefined parameters are not set in the date object, which the API sees as a\r\n  // wildcard.\r\n  function constructDate(year, month, day) {\r\n    const date = {};\r\n    if (year) date.year = year;\r\n    if (month) date.month = month;\r\n    if (day) date.day = day;\r\n    return date;\r\n  }\r\n  // Submits a search request to the Google Photos Library API for the given\r\n  // parameters. The authToken is used to authenticate requests for the API.\r\n  // The minimum number of expected results is configured in config.photosToLoad.\r\n  // This function makes multiple calls to the API to load at least as many photos\r\n  // as requested. This may result in more items being listed in the response than\r\n  // originally requested.\r\n  async function libraryApiSearch(authToken, parameters) {\r\n    let photos = [];\r\n    let nextPageToken = null;\r\n    let error = null;\r\n\r\n    parameters.pageSize = config.searchPageSize;\r\n\r\n    try {\r\n      // Loop while the number of photos threshold has not been met yet\r\n      // and while there is a nextPageToken to load more items.\r\n      do {\r\n        logger.info(\r\n          `Submitting search with parameters: ${JSON.stringify(parameters)}`\r\n        );\r\n\r\n        // Make a POST request to search the library or album\r\n        const result = await request.post(\r\n          config.apiEndpoint + \"/v1/mediaItems:search\",\r\n          {\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            json: parameters,\r\n            auth: { bearer: authToken }\r\n          }\r\n        );\r\n\r\n        logger.debug(`Response: ${result}`);\r\n\r\n        // The list of media items returned may be sparse and contain missing\r\n        // elements. Remove all invalid elements.\r\n        // Also remove all elements that are not images by checking its mime type.\r\n        // Media type filters can't be applied if an album is loaded, so an extra\r\n        // filter step is required here to ensure that only images are returned.\r\n        const items =\r\n          result && result.mediaItems\r\n            ? result.mediaItems\r\n                .filter(x => x) // Filter empty or invalid items.\r\n                // Only keep media items with an image mime type.\r\n                .filter(x => x.mimeType && x.mimeType.startsWith(\"image/\"))\r\n            : [];\r\n\r\n        photos = photos.concat(items);\r\n\r\n        // Set the pageToken for the next request.\r\n        parameters.pageToken = result.nextPageToken;\r\n\r\n        logger.verbose(\r\n          `Found ${items.length} images in this request. Total images: ${\r\n            photos.length\r\n          }`\r\n        );\r\n\r\n        // Loop until the required number of photos has been loaded or until there\r\n        // are no more photos, ie. there is no pageToken.\r\n      } while (\r\n        photos.length < config.photosToLoad &&\r\n        parameters.pageToken != null\r\n      );\r\n    } catch (err) {\r\n      // If the error is a StatusCodeError, it contains an error.error object that\r\n      // should be returned. It has a name, statuscode and message in the correct\r\n      // format. Otherwise extract the properties.\r\n      error = err.error.error || {\r\n        name: err.name,\r\n        code: err.statusCode,\r\n        message: err.message\r\n      };\r\n      logger.error(error);\r\n    }\r\n\r\n    logger.info(\"Search complete.\");\r\n    return { photos, parameters, error };\r\n  }\r\n\r\n  // Returns a list of all albums owner by the logged in user from the Library\r\n  // API.\r\n  async function libraryApiGetAlbums(authToken) {\r\n    let albums = [];\r\n    let nextPageToken = null;\r\n    let error = null;\r\n    let parameters = { pageSize: config.albumPageSize };\r\n\r\n    try {\r\n      // Loop while there is a nextpageToken property in the response until all\r\n      // albums have been listed.\r\n      do {\r\n        logger.verbose(`Loading albums. Received so far: ${albums.length}`);\r\n        // Make a GET request to load the albums with optional parameters (the\r\n        // pageToken if set).\r\n        const result = await request.get(config.apiEndpoint + \"/v1/albums\", {\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          qs: parameters,\r\n          json: true,\r\n          auth: { bearer: authToken }\r\n        });\r\n\r\n        logger.debug(`Response: ${result}`);\r\n\r\n        if (result && result.albums) {\r\n          logger.verbose(`Number of albums received: ${result.albums.length}`);\r\n          // Parse albums and add them to the list, skipping empty entries.\r\n          const items = result.albums.filter(x => !!x);\r\n\r\n          albums = albums.concat(items);\r\n        }\r\n        parameters.pageToken = result.nextPageToken;\r\n        // Loop until all albums have been listed and no new nextPageToken is\r\n        // returned.\r\n      } while (parameters.pageToken != null);\r\n    } catch (err) {\r\n      // If the error is a StatusCodeError, it contains an error.error object that\r\n      // should be returned. It has a name, statuscode and message in the correct\r\n      // format. Otherwise extract the properties.\r\n      error = err.error.error || {\r\n        name: err.name,\r\n        code: err.statusCode,\r\n        message: err.message\r\n      };\r\n      logger.error(error);\r\n    }\r\n\r\n    logger.info(\"Albums loaded.\");\r\n    return { albums, error };\r\n  }\r\n\r\n  return app;\r\n};\r\n\r\nmodule.exports = addRoutes;\r\n","module.exports = require(\"request\");","module.exports = require(\"serve-static\");","const { Router } = require(\"express\");\r\nconst { paths } = require(\"./methods\");\r\n\r\nconst path = \"/auth\";\r\nconst base = Router().route(path);\r\npaths.forEach(({ method, path, resolver }) => base[method](path, resolver));\r\n\r\nmodule.exports = base;\r\n","const { logout } = require(\"./logout.js\");\r\nconst { googleLogin } = require(\"./login.js\");\r\nconst { googleLoginCallback } = require(\"./redirect.js\");\r\n\r\nmodule.exports.paths = [logout, googleLogin, googleLoginCallback];\r\n","module.exports.logout = {\r\n  method: \"get\",\r\n  path: \"/logout\",\r\n  resolver: (req, res) => {\r\n    req.logout();\r\n    req.session.destroy();\r\n    res.redirect(\"/\");\r\n  }\r\n};\r\n","const { config } = require(\"~config\");\r\nconst { passport } = require(\"~express/middleware/auth/passport.js\");\r\n\r\nmodule.exports.googleLogin = {\r\n  method: \"get\",\r\n  path: \"/google\",\r\n  resolver: passport.authenticate(\"google\", {\r\n    scope: config.scopes,\r\n    failureFlash: true, // Display errors to the user.\r\n    session: true\r\n  })\r\n};\r\n","const { passport } = require(\"~express/middleware/auth/passport.js\");\r\n\r\nmodule.exports.googleLoginCallback = {\r\n  method: \"get\",\r\n  path: \"/google/callback\",\r\n  resolver: [\r\n    passport.authenticate(\"google\", {\r\n      failureRedirect: \"/\",\r\n      failureFlash: true,\r\n      session: true\r\n    }),\r\n    function(req, res) {\r\n      res.send(`<script>window.close()</script>`);\r\n    }\r\n  ]\r\n};\r\n","module.exports = require(\"~express/middleware/logging\");","import { Home } from \"~marko\";\r\n\r\nconst routeMarkoPages = app => {\r\n  app.get(\"/\", (req, res) => {\r\n    res.setHeader(\"Content-Type\", \"text/html; charset=utf-8\");\r\n    Home.render({}, res);\r\n  });\r\n  return app;\r\n};\r\n\r\nexport { routeMarkoPages };\r\n"],"sourceRoot":""}